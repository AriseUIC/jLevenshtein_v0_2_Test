/*
 * jLevenshtein: An extended Damerau-Levenshtein distance implementation
 * 
 * Copyright (C) 2010 Rafael W.
 * 
 * This file is part of jLevenshtein on sourceforge.net
 *
 * jLevenshtein is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * jLevenshtein is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with jLevenshtein. If not, see http://www.gnu.org/licenses/.
 *
 */
package net.sourceforge.jlevenshtein;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.TreeMap;

/**
 * <p>This class offers various functions to describe the comparison process of the 
 * {@link Levenshtein} algorithm in this package. All results of this class are final and 
 * are consequently this object is immutable. To optimize possible long time storage of
 * serialized instances this class does not remember any computation flags or operation 
 * costs that were used by the generating <code>Levenshtein</code> object.</p>
 * 
 * <p>This class is not compatible to the Java Beans framework since the later requires setter
 * methods which do not make sense for this descriptive class.</p>
 * @author Rafael W.
 * @version 0.2
 * @see Levenshtein
 */
public final class ComparedStrings extends BasicCompared implements Serializable {
	
	/**
	 * A class that describes a transformation occurring in a levenshtein path that was generated by 
	 * a <code>ComparedStrings</code> object.
	 * @author Rafael W.
	 * @version 0.1
	 * @since jLevenshtein v0.2
	 */
	public static class Transformation implements Serializable {
		
		/**
		 * Serial ID (v0.1)
		 */
		private static final long serialVersionUID = 1L;

		/**
		 * The character index of the first word at which a character is inserted, deleted, substituted or swapped
		 */
		public final int transformPosition;
		
		/**
		 * The character index of the second word which is inserted, substituted or swapped or <code>-1</code> if
		 * this field does not apply
		 */
		public final int insertPosition;
		
		/**
		 * The transformation action that is represented by this object
		 */
		public final int action;
		
		/**
		 * Creates a new Levenshtein transformation.
		 * @param action The action that was undertaken
		 * @param transformPosition The character index of the first word that is linked to this transformation
		 * @param insertPosition The character index of the second word that is linked to this transformation
		 */
		private Transformation(int action, int transformPosition, int insertPosition) {
			this.action = action;
			this.transformPosition = transformPosition;
			this.insertPosition = insertPosition;
		}
		
		/**
		 * A user readable <code>toString</code> function. The first integer represents the action ID of
		 * the transformations while the second and third integer represent <code>transformPosition</code>
		 * and <code>insertPosition</code>.
		 */
		@Override
		public String toString() {
			return new StringBuilder("ComparedStrings.Transformation[").append(action).append(':')
				.append(transformPosition).append(',').append(insertPosition).append(']').toString();
		}
		
	}
	
	/**
	 * Serial version ID - since v0.1
	 */
	private static final long serialVersionUID = 1L;
	
	/**
	 * The first user input string
	 */
	private final String firstInput;
	
	/**
	 * The second user input string
	 */
	private final String secondInput;
	
	/**
	 * The first sequence of words of user input
	 */
	private final String[] wordsFirstInput;
	
	/**
	 * The second sequence of words of the user input
	 */
	private final String[] wordsSecondInput;
	
	/**
	 * A matrix with the compared similarities of all words
	 */
	private final float[][] comparedResults;
	
	/**
	 * A map containing all possible comparisons
	 */
	private final Map<HashPoint,float[][]> matrixCollection;
	
	/**
	 * Basic constructor (for internal use only) that builds the object
	 * @param basicCompared The internal basic compared object that was constructed before
	 * @param firstInput The users first input String
	 * @param secondInput The users second input String
	 * @param wordsFirstInput The sequence of words of the users first input String
	 * @param wordsSecondInput The sequence of words of the users second input String
	 * @param comparedResults The matrix of compared results
	 * @param matrixCollection A collection of Levenshtein matrices word to word
	 */
	protected ComparedStrings(BasicCompared basicCompared, String firstInput, String secondInput, String[] wordsFirstInput, 
			String[] wordsSecondInput, float[][] comparedResults, Map<HashPoint,float[][]> matrixCollection) {
		
		super(basicCompared);
		this.firstInput = firstInput;
		this.secondInput = secondInput;
		this.wordsFirstInput = stringsSwapped ? wordsSecondInput : wordsFirstInput;
		this.wordsSecondInput = stringsSwapped ? wordsFirstInput : wordsSecondInput;
		this.comparedResults = comparedResults;
		this.matrixCollection = matrixCollection;
		
	}
	
	/**
	 * Returns the ID (position - 1) of the word in the second sequence that was matched to the word in the first sequence carrying this ID
	 * @param id The ID of the first word in the first sequence
	 * @return The ID of the matched word in the second sequence (-1 word not matched)
	 * @throws IndexOutOfBoundsException If the ID does not exist
	 */
	public int matchFirst(int id) throws IndexOutOfBoundsException {
		return match(id, true);

	}
	
	/**
	 * Returns the ID (position - 1) of the word in the first sequence that was matched to the word in the second sequence carrying this ID
	 * @param id The ID of the first word in the second sequence
	 * @return The ID of the matching word in the first sequence (-1 word not matched)
	 * @throws IndexOutOfBoundsException If the ID does not exist
	 */
	public int matchSecond(int id) throws IndexOutOfBoundsException {
		return match(id, false);

	}
	
	/**
	 * Function that returns the highest valid word ID for the first input string
	 * @return The ID
	 */
	public int maxIDFirst() {
		return wordsFirstInput.length - 1;
	}
	
	/**
	 * Function that returns the highest valid word ID for the second input string
	 * @return The ID
	 */
	public int maxIDSecond() {
		return wordsSecondInput.length - 1;
	}
	
	/**
	 * Internal function to compute the return value
	 * @param id The word ID
	 * @param noSwap <code>true</code> if called for first sequence, <code>false</code> if called for the second
	 * @return The matching word ID as above
	 * @throws IndexOutOfBoundsException If the ID does not exist
	 */
	private int match(int id, boolean noSwap) throws IndexOutOfBoundsException {
				
		Map<Integer,Integer> tempComparedMapping = noSwap ? firstComparedMapping : secondComparedMapping;
		String[] tempWordsInput = noSwap ? wordsFirstInput : wordsSecondInput;
		
		if(id < 0 || id >= tempWordsInput.length) {
			throw new IndexOutOfBoundsException("This ID does not exist.");
		} else if(tempComparedMapping.containsKey(id)) {
			return tempComparedMapping.get(id).intValue();
		} else {
			return -1;
		}
		
	}
	
	/**
	 * Returns the user's first input String that was compared
	 * @return The sequence that was compared
	 */
	public String getFirst() {
		return this.firstInput;
	}
	
	/**
	 * Returns the user's second input String that was compared
	 * @return The sequence that was compared
	 */
	public String getSecond() {
		return this.secondInput;
	}
	
	/**
	 * Returns the element with the corresponding word ID in the first string
	 * @param elementID The ID of the element
	 * @return The corresponding word
	 * @throws IndexOutOfBoundsException If the ID does not exist
	 */
	public String getFirst(int elementID) {
		
		if(elementID >= 0 && elementID < wordsFirstInput.length) {
			return wordsFirstInput[elementID];
		} else {
			throw new IndexOutOfBoundsException("This ID does not exist.");
		}
		
	}
	
	/**
	 * Returns the element with the corresponding word ID in the second string
	 * @param elementID The ID of the element
	 * @return The corresponding word or null if ID does not exist
	 * @throws IndexOutOfBoundsException If the ID does not exist
	 */
	public String getSecond(int elementID) {
		
		if(elementID >= 0 && elementID < wordsSecondInput.length) {
			return wordsSecondInput[elementID];
		} else {
			throw new IndexOutOfBoundsException("This ID does not exist.");
		}
		
	}
	
	/**
	 * Returns the similarity index of two given words
	 * @param firstWordID The ID of the word in the first sequence
	 * @param secondWordID The ID of the word in the second sequence
	 * @return The similarity index
	 * @throws IndexOutOfBoundsException If at least one of the ID does not exist
	 */
	public float index(int firstWordID, int secondWordID) throws IndexOutOfBoundsException {

		// Swap index values if necessary
		if(stringsSwapped == true) {
			firstWordID += secondWordID;
			secondWordID = firstWordID - secondWordID;
			firstWordID -= secondWordID;
		}
		
		// Look up pairwise ID in matrix if exists
		if(firstWordID >= 0 && firstWordID < comparedResults.length && 
				secondWordID >= 0 && secondWordID < comparedResults[0].length) {
			
			return comparedResults[firstWordID][secondWordID];
			
		} else {
			 throw new IndexOutOfBoundsException("At least one of the IDs does not exist.");
		}
		
	}
	
	/**
	 * Returns the Levenshtein distance of two words words
	 * @param firstWordID The ID of the word in the first sequence
	 * @param secondWordID The ID of the word in the second sequence
	 * @return The Levenshtein distance between both words
	 * @throws IndexOutOfBoundsException If at least one of the ID does not exist
	 */
	public float distance(int firstWordID, int secondWordID) throws IndexOutOfBoundsException {

		float[][] tempMatrix = getLevenshteinMatrix(firstWordID, secondWordID);
		return tempMatrix[tempMatrix.length-1][tempMatrix[0].length-1];
		
	}
	
	/**
	 * The Levenshtein distance matrix for two given words
	 * @param firstWordID The ID of the word in the first sequence
	 * @param secondWordID The ID of the word in the second sequence
	 * @return The Levenshtein matrix of two items
	 * @throws IndexOutOfBoundsException If at least one of the ID does not exist
	 */
	public float[][] getLevenshteinMatrix(int firstWordID, int secondWordID) throws IndexOutOfBoundsException {
		
		if(firstWordID >= 0 && firstWordID < comparedResults.length && 
				secondWordID >= 0 && secondWordID < comparedResults[0].length) {

			return matrixCollection.get(new HashPoint(firstWordID, secondWordID)).clone();
		
		} else {
			throw new IndexOutOfBoundsException("At least one of the IDs does not exist.");
		}
		
	}
	
	/**
	 * Returns the optimal path of transformation
	 * @param firstWordID The ID of the first word
	 * @param secondWordID The ID of the second word
	 * @return A map that contains HashPoints as keys. These are (x,y) coordinates that have unique hash values
	 * 		for their x,y coordinates. The corresponding Integer will indicate the transformation action done at 
	 * 		this point to yield one string out of the other. (As described by the <code>ACTION_*</code> constants 
	 * 		x can be interpreted as a columns and y as a row in the Levenshtein matrix. (starting at origin (0,0))
	 * @throws IndexOutOfBoundsException If at least one of the ID does not exist
	 */
	public Map<HashPoint,Integer> levenshteinPath(int firstWordID, int secondWordID) throws IndexOutOfBoundsException {
		return Levenshtein.getIdealPath(getLevenshteinMatrix(firstWordID, secondWordID));
		
	}
	
	/**
	 * <p>This convenience wrapper function filters all real transformations that have to be undertaken on the first
	 * string to transform the later into the second string. Both strings have to be represented by a path that is yielded
	 * by the <code>levenshteinPath</code> method of an existing <code>ComparedStrings</code> object.</p>
	 * 
	 * <p>All resulting transformations are represented by <code>ComparedStrings.Transformation</code> objects that describe 
	 * one step of the transformation. The character index of these objects is always relative to the original
	 * string length of the input path. Therefore, transformation skips may be skipped by the user while discarding all
	 * previous transformations. However, if the original strings are manipulated, it remains the user's responsibility
	 * to remember the change of any character indices. All alteration details remain in the resulting array but the 
	 * construction of the <code>Transformation</code> objects will take additional time which is why working with the 
	 * original path object is recommended for time consuming computations. Note that the number of resulting 
	 * transformations is strictly smaller than the number of Levenshtein path nodes since <code>ACTION_START</code> 
	 * and <code>ACTION_REMAIN</code> nodes do not trigger a real transformation and are therefore filtered out.</p>
	 * @param levenshteinPath A Levenshtein path that describes the transformation of one string into another.
	 * @return An array with all real transformations to yield the second string out of the first string
	 * @since jLevenshtein v0.2
	 */
	public static Transformation[] editTransformation(Map<HashPoint,Integer> levenshteinPath) {
		
		List<Transformation> transformations = new ArrayList<Transformation>(levenshteinPath.size() - 1);
		
		int action;
		for(Entry<HashPoint,Integer> entry : new TreeMap<HashPoint,Integer>(levenshteinPath).entrySet()) {
				
			switch(action = entry.getValue().intValue()) {
			
				case Levenshtein.ACTION_SUBSTITUTE: transformations.add(new Transformation(action, 
														entry.getKey().y - 1, entry.getKey().x - 1));
													break;
														
				case Levenshtein.ACTION_INSERT: 	transformations.add(new Transformation(action, 
														entry.getKey().y, entry.getKey().x - 1));
													break;
														
				case Levenshtein.ACTION_DELETE: 	transformations.add(new Transformation(action, 
														entry.getKey().y - 1, -1));
													break;
														
				case Levenshtein.ACTION_SWAP:	 	transformations.add(new Transformation(action, 
														entry.getKey().y - 2, entry.getKey().x - 1));
													break;
													
			}
			
		}
		
		return transformations.toArray(new Transformation[0]);
		
	}
	
	/**
	 * <p>This convenience wrapper function filters all real transformations that have to be undertaken on the first
	 * string to transform the later into the second string. Both strings have to be represented by a path that is yielded
	 * by the <code>levenshteinPath</code> method of an existing <code>ComparedStrings</code> object.</p>
	 * 
	 * <p>All resulting transformations are represented by <code>String</code> objects that stand for one step of the 
	 * transformation. Any further transformation details described by the original Levenshtein path are lost. Note that 
	 * the number of transformations is strictly smaller than the number of Levenshtein path nodes since <code>ACTION_START</code>
	 * and <code>ACTION_REMAIN</code> nodes do not trigger a real transformation and are therefore filtered out.</p>
	 * @param levenshteinPath The transformation path that alters one string into another
	 * @param firstWord The first word that is represented by <code>levenshteinPath</code>
	 * @param secondWord The second word that is represented by <code>levenshteinPath</code>
	 * @return An array of strings that describes all transformation steps including in their order
	 * @since jLevenshtein v0.2
	 */
	public static String[] resultTransformation(Map<HashPoint,Integer> levenshteinPath, String firstWord, String secondWord) {
		
		StringBuilder sb = new StringBuilder(firstWord);
		char[] secondWordChars = secondWord.toCharArray();
		sb.ensureCapacity(secondWordChars.length);
		
		int firstWordIndexShifted = 0;
		List<String> transformations = new ArrayList<String>(levenshteinPath.size() - 1);
		transformations.add(firstWord);
		
		loop: for(Entry<HashPoint,Integer> entry : new TreeMap<HashPoint,Integer>(levenshteinPath).entrySet()) {
				
			switch(entry.getValue().intValue()) {
			
				case Levenshtein.ACTION_SUBSTITUTE: sb.setCharAt(entry.getKey().y - 1 + firstWordIndexShifted, 
														secondWordChars[entry.getKey().x - 1]);
													break;
														
				case Levenshtein.ACTION_INSERT: 	sb.insert(entry.getKey().y + firstWordIndexShifted, 
														secondWordChars[entry.getKey().x - 1]);
													firstWordIndexShifted++;
													break;
														
				case Levenshtein.ACTION_DELETE: 	sb.deleteCharAt(entry.getKey().y - 1 + firstWordIndexShifted);
													firstWordIndexShifted--;
													break;
														
				case Levenshtein.ACTION_SWAP:	 	sb.setCharAt(entry.getKey().y - 1 + firstWordIndexShifted, 
														secondWordChars[entry.getKey().x - 1]);
													sb.setCharAt(entry.getKey().y - 2 + firstWordIndexShifted, 
														secondWordChars[entry.getKey().x - 2]);
													break;
													
				default:							continue loop;
				
			}
			
			transformations.add(sb.toString());
			
		}
		
		return transformations.toArray(new String[0]);
		
	}
	
}